# Polymarket Dump & Hedge 自动化交易系统
## 回测框架设计文档

**文档版本**: v1.0  
**创建日期**: 2025年12月30日  
**作者**: Kyd  

---

## 1. 回测目标

### 1.1 核心目标
- 验证Dump & Hedge策略在历史数据上的有效性
- 找到最优参数组合，最大化风险调整后收益
- 评估策略在不同市场条件下的稳健性

### 1.2 设计原则
- **保守估计**: 宁可低估收益，不高估表现
- **真实模拟**: 尽可能模拟真实交易环境
- **可复现**: 相同输入产生相同输出
- **高效执行**: 支持大规模参数扫描

---

## 2. 回测架构

### 2.1 系统架构

```
┌─────────────────────────────────────────────────────────────────┐
│                      Backtest Framework                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌──────────────┐    ┌──────────────┐    ┌──────────────┐       │
│  │  Data Loader │───►│ Replay Engine│───►│Report Generator│      │
│  └──────────────┘    └──────┬───────┘    └──────────────┘       │
│                             │                                    │
│                             ▼                                    │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │                    Simulation Core                        │   │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐  │   │
│  │  │  State   │  │  Dump    │  │  Hedge   │  │   Fee    │  │   │
│  │  │ Machine  │  │ Detector │  │ Strategy │  │Calculator│  │   │
│  │  └──────────┘  └──────────┘  └──────────┘  └──────────┘  │   │
│  └──────────────────────────────────────────────────────────┘   │
│                                                                  │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │                    Portfolio Tracker                      │   │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐               │   │
│  │  │  Balance │  │ Position │  │  P&L     │               │   │
│  │  │  Manager │  │  Tracker │  │Calculator│               │   │
│  │  └──────────┘  └──────────┘  └──────────┘               │   │
│  └──────────────────────────────────────────────────────────┘   │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 2.2 数据流

```
Historical Data (SQLite)
        │
        ▼
┌───────────────┐
│  Data Loader  │───► 验证数据完整性
└───────┬───────┘     检测数据缺口
        │
        ▼
┌───────────────┐
│ Replay Engine │───► 按时间顺序回放
└───────┬───────┘     模拟WebSocket数据流
        │
        ▼
┌───────────────┐
│Simulation Core│───► 执行策略逻辑
└───────┬───────┘     记录所有决策
        │
        ▼
┌───────────────┐
│ Report Gen    │───► 生成回测报告
└───────────────┘     输出性能指标
```

---

## 3. 数据管理

### 3.1 数据录制

由于Polymarket历史API对BTC 15分钟市场返回空数据，需要自建数据录制系统。

**录制格式**:
```typescript
interface RecordedTick {
  timestamp: number;          // Unix毫秒时间戳
  roundSlug: string;          // 轮次标识
  secondsRemaining: number;   // 剩余秒数
  upTokenId: string;
  downTokenId: string;
  upBestAsk: number;
  upBestBid: number;
  downBestAsk: number;
  downBestBid: number;
}
```

**录制脚本**:
```javascript
class DataRecorder {
  constructor(dbPath) {
    this.db = new Database(dbPath);
    this.buffer = [];
    this.flushInterval = 1000; // 每秒flush一次
  }

  async start() {
    // 初始化表
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS price_ticks (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        timestamp INTEGER NOT NULL,
        round_slug TEXT NOT NULL,
        seconds_remaining INTEGER,
        up_token_id TEXT,
        down_token_id TEXT,
        up_best_ask REAL,
        up_best_bid REAL,
        down_best_ask REAL,
        down_best_bid REAL
      );
      CREATE INDEX IF NOT EXISTS idx_timestamp ON price_ticks(timestamp);
    `);

    // 连接WebSocket
    this.ws = new WebSocket(POLYMARKET_WS_URL);
    this.ws.on('message', this.handleTick.bind(this));

    // 定时flush
    setInterval(() => this.flush(), this.flushInterval);
  }

  handleTick(data) {
    const tick = JSON.parse(data);
    this.buffer.push({
      timestamp: Date.now(),
      roundSlug: tick.roundSlug,
      secondsRemaining: tick.secondsRemaining,
      upTokenId: tick.upTokenId,
      downTokenId: tick.downTokenId,
      upBestAsk: parseFloat(tick.upBestAsk),
      upBestBid: parseFloat(tick.upBestBid),
      downBestAsk: parseFloat(tick.downBestAsk),
      downBestBid: parseFloat(tick.downBestBid)
    });
  }

  flush() {
    if (this.buffer.length === 0) return;

    const stmt = this.db.prepare(`
      INSERT INTO price_ticks 
      (timestamp, round_slug, seconds_remaining, up_token_id, down_token_id,
       up_best_ask, up_best_bid, down_best_ask, down_best_bid)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
    `);

    const insertMany = this.db.transaction((ticks) => {
      for (const tick of ticks) {
        stmt.run(
          tick.timestamp, tick.roundSlug, tick.secondsRemaining,
          tick.upTokenId, tick.downTokenId,
          tick.upBestAsk, tick.upBestBid, tick.downBestAsk, tick.downBestBid
        );
      }
    });

    insertMany(this.buffer);
    console.log(`Flushed ${this.buffer.length} ticks`);
    this.buffer = [];
  }
}
```

### 3.2 数据质量检查

```javascript
class DataQualityChecker {
  checkContinuity(db, startTime, endTime) {
    // 检查数据缺口
    const gaps = [];
    const expectedInterval = 1000; // 预期1秒一条
    const maxGap = 5000; // 超过5秒视为缺口

    const rows = db.prepare(`
      SELECT timestamp FROM price_ticks
      WHERE timestamp BETWEEN ? AND ?
      ORDER BY timestamp ASC
    `).all(startTime, endTime);

    for (let i = 1; i < rows.length; i++) {
      const gap = rows[i].timestamp - rows[i-1].timestamp;
      if (gap > maxGap) {
        gaps.push({
          start: rows[i-1].timestamp,
          end: rows[i].timestamp,
          duration: gap
        });
      }
    }

    return gaps;
  }

  checkDataRange(db) {
    const stats = db.prepare(`
      SELECT 
        MIN(timestamp) as minTime,
        MAX(timestamp) as maxTime,
        COUNT(*) as totalTicks,
        COUNT(DISTINCT round_slug) as totalRounds
      FROM price_ticks
    `).get();

    return {
      ...stats,
      duration: (stats.maxTime - stats.minTime) / (1000 * 60 * 60), // hours
      avgTicksPerSecond: stats.totalTicks / ((stats.maxTime - stats.minTime) / 1000)
    };
  }
}
```

---

## 4. 回测引擎

### 4.1 Replay Engine

```javascript
class ReplayEngine {
  constructor(config) {
    this.config = config;
    this.currentTime = 0;
    this.events = [];
  }

  async load(db, startTime, endTime) {
    // 加载历史数据
    const ticks = db.prepare(`
      SELECT * FROM price_ticks
      WHERE timestamp BETWEEN ? AND ?
      ORDER BY timestamp ASC
    `).all(startTime, endTime);

    console.log(`Loaded ${ticks.length} ticks`);
    this.ticks = ticks;
    this.index = 0;
  }

  *replay() {
    // Generator函数，逐tick回放
    for (const tick of this.ticks) {
      this.currentTime = tick.timestamp;
      yield {
        type: 'TICK',
        data: tick
      };

      // 检测轮次切换
      if (this.index > 0 && 
          this.ticks[this.index].roundSlug !== this.ticks[this.index - 1].roundSlug) {
        yield {
          type: 'ROUND_CHANGE',
          data: {
            oldRound: this.ticks[this.index - 1].roundSlug,
            newRound: this.ticks[this.index].roundSlug
          }
        };
      }

      this.index++;
    }
  }
}
```

### 4.2 Simulation Core

```javascript
class BacktestSimulator {
  constructor(config, replayEngine) {
    this.config = config;
    this.replayEngine = replayEngine;
    
    // 初始化组件
    this.stateMachine = new BacktestStateMachine();
    this.dumpDetector = new DumpDetector(config);
    this.hedgeStrategy = new HedgeStrategy(config);
    this.portfolio = new PortfolioTracker(config.initialBalance);
    this.feeCalculator = new FeeCalculator(config.feeRate, config.spreadBuffer);
    
    // 价格缓冲
    this.priceBuffer = new CircularBuffer(100);
    
    // 结果记录
    this.trades = [];
    this.cycles = [];
    this.equityCurve = [];
  }

  run() {
    let roundStartTime = null;

    for (const event of this.replayEngine.replay()) {
      if (event.type === 'ROUND_CHANGE') {
        // 轮次切换处理
        this.handleRoundChange(event.data);
        roundStartTime = this.replayEngine.currentTime;
        continue;
      }

      const tick = event.data;
      
      // 更新价格缓冲
      this.priceBuffer.push({
        timestamp: tick.timestamp,
        upBestAsk: tick.up_best_ask,
        downBestAsk: tick.down_best_ask
      });

      // 根据状态执行逻辑
      switch (this.stateMachine.state) {
        case 'WATCHING':
          this.handleWatching(tick, roundStartTime);
          break;
        case 'WAITING_HEDGE':
          this.handleWaitingHedge(tick);
          break;
      }

      // 记录权益曲线
      if (tick.timestamp % 60000 < 1000) { // 每分钟记录一次
        this.equityCurve.push({
          timestamp: tick.timestamp,
          equity: this.portfolio.getEquity()
        });
      }
    }

    return this.generateReport();
  }

  handleWatching(tick, roundStartTime) {
    if (!roundStartTime) return;

    const signal = this.dumpDetector.detect(this.priceBuffer, roundStartTime);
    
    if (signal) {
      // 执行Leg 1
      const fillPrice = this.feeCalculator.applySlippage(signal.price, 'BUY');
      const cost = fillPrice * this.config.shares;
      const fee = this.feeCalculator.calculateFee(cost);
      
      if (this.portfolio.balance >= cost + fee) {
        this.portfolio.balance -= (cost + fee);
        
        this.currentCycle = {
          id: generateId(),
          roundSlug: tick.round_slug,
          leg1: {
            side: signal.side,
            shares: this.config.shares,
            price: fillPrice,
            cost: cost + fee,
            timestamp: tick.timestamp
          },
          leg2: null
        };
        
        this.stateMachine.transition('LEG1_FILLED');
        this.stateMachine.transition('WAITING_HEDGE');
      }
    }
  }

  handleWaitingHedge(tick) {
    const leg1Side = this.currentCycle.leg1.side;
    const oppositeSide = leg1Side === 'UP' ? 'DOWN' : 'UP';
    const oppositeAsk = oppositeSide === 'UP' ? tick.up_best_ask : tick.down_best_ask;
    
    if (this.hedgeStrategy.shouldHedge(this.currentCycle.leg1.price, oppositeAsk)) {
      // 执行Leg 2
      const fillPrice = this.feeCalculator.applySlippage(oppositeAsk, 'BUY');
      const cost = fillPrice * this.config.shares;
      const fee = this.feeCalculator.calculateFee(cost);
      
      this.portfolio.balance -= (cost + fee);
      
      this.currentCycle.leg2 = {
        side: oppositeSide,
        shares: this.config.shares,
        price: fillPrice,
        cost: cost + fee,
        timestamp: tick.timestamp
      };
      
      // 计算收益
      const totalCost = this.currentCycle.leg1.cost + this.currentCycle.leg2.cost;
      const guaranteedReturn = 1.0 * this.config.shares;
      const profit = guaranteedReturn - totalCost;
      
      this.currentCycle.profit = profit;
      this.currentCycle.status = 'COMPLETED';
      
      this.portfolio.balance += guaranteedReturn;
      this.cycles.push(this.currentCycle);
      this.trades.push(this.currentCycle.leg1, this.currentCycle.leg2);
      
      this.stateMachine.transition('COMPLETED');
      this.stateMachine.transition('IDLE');
      this.stateMachine.transition('WATCHING');
    }
  }

  handleRoundChange(data) {
    // 如果有未对冲的Leg1，按全损处理 (保守假设)
    if (this.stateMachine.state === 'WAITING_HEDGE' && this.currentCycle) {
      this.currentCycle.status = 'EXPIRED_LOSS';
      this.currentCycle.profit = -this.currentCycle.leg1.cost;
      this.cycles.push(this.currentCycle);
      this.trades.push(this.currentCycle.leg1);
    }
    
    this.stateMachine.transition('IDLE');
    this.stateMachine.transition('WATCHING');
    this.currentCycle = null;
    this.priceBuffer.clear();
  }

  generateReport() {
    return new BacktestReport(this.config, this.trades, this.cycles, this.equityCurve, this.portfolio);
  }
}
```

### 4.3 费用计算

```javascript
class FeeCalculator {
  constructor(feeRate = 0.005, spreadBuffer = 0.02) {
    this.feeRate = feeRate;           // 0.5% 手续费
    this.spreadBuffer = spreadBuffer;  // 2% 滑点缓冲
  }

  calculateFee(amount) {
    return amount * this.feeRate;
  }

  applySlippage(price, side) {
    // 买入时价格上浮，卖出时价格下浮
    if (side === 'BUY') {
      return price * (1 + this.spreadBuffer / 2);
    } else {
      return price * (1 - this.spreadBuffer / 2);
    }
  }

  // 总成本 = 价格 * 数量 * (1 + 滑点) * (1 + 手续费)
  calculateTotalCost(price, shares) {
    const slippagePrice = this.applySlippage(price, 'BUY');
    const baseCost = slippagePrice * shares;
    return baseCost * (1 + this.feeRate);
  }
}
```

---

## 5. 参数优化

### 5.1 网格搜索

```javascript
class ParameterOptimizer {
  constructor(db, baseConfig) {
    this.db = db;
    this.baseConfig = baseConfig;
  }

  gridSearch(paramRanges) {
    const results = [];
    
    // 生成所有参数组合
    const combinations = this.generateCombinations(paramRanges);
    console.log(`Testing ${combinations.length} parameter combinations`);

    for (const params of combinations) {
      const config = { ...this.baseConfig, ...params };
      
      const replay = new ReplayEngine(config);
      replay.load(this.db, config.startTime, config.endTime);
      
      const simulator = new BacktestSimulator(config, replay);
      const report = simulator.run();
      
      results.push({
        params,
        metrics: report.getMetrics()
      });
    }

    // 按Sharpe Ratio排序
    results.sort((a, b) => b.metrics.sharpeRatio - a.metrics.sharpeRatio);
    
    return results;
  }

  generateCombinations(ranges) {
    const keys = Object.keys(ranges);
    const combinations = [];
    
    function recurse(index, current) {
      if (index === keys.length) {
        combinations.push({ ...current });
        return;
      }
      
      const key = keys[index];
      const values = ranges[key];
      
      for (const value of values) {
        current[key] = value;
        recurse(index + 1, current);
      }
    }
    
    recurse(0, {});
    return combinations;
  }
}

// 使用示例
const paramRanges = {
  sumTarget: [0.90, 0.92, 0.95, 0.97],
  movePct: [0.05, 0.10, 0.15, 0.20],
  windowMin: [1, 2, 3, 5],
  shares: [10, 20, 50]
};

const optimizer = new ParameterOptimizer(db, baseConfig);
const results = optimizer.gridSearch(paramRanges);

console.log('Top 5 parameter sets:');
results.slice(0, 5).forEach((r, i) => {
  console.log(`${i + 1}. ROI: ${(r.metrics.roi * 100).toFixed(2)}%, Sharpe: ${r.metrics.sharpeRatio.toFixed(2)}`);
  console.log(`   Params: ${JSON.stringify(r.params)}`);
});
```

### 5.2 指标定义

```javascript
class BacktestReport {
  constructor(config, trades, cycles, equityCurve, portfolio) {
    this.config = config;
    this.trades = trades;
    this.cycles = cycles;
    this.equityCurve = equityCurve;
    this.portfolio = portfolio;
  }

  getMetrics() {
    const winningCycles = this.cycles.filter(c => c.profit > 0);
    const losingCycles = this.cycles.filter(c => c.profit <= 0);
    
    // 基础指标
    const totalProfit = this.cycles.reduce((sum, c) => sum + (c.profit || 0), 0);
    const roi = totalProfit / this.config.initialBalance;
    const winRate = winningCycles.length / this.cycles.length;
    
    // 风险指标
    const returns = this.calculateReturns();
    const sharpeRatio = this.calculateSharpe(returns);
    const maxDrawdown = this.calculateMaxDrawdown();
    const sortinoRatio = this.calculateSortino(returns);
    
    // 交易统计
    const avgProfit = totalProfit / this.cycles.length;
    const avgWin = winningCycles.reduce((sum, c) => sum + c.profit, 0) / winningCycles.length || 0;
    const avgLoss = losingCycles.reduce((sum, c) => sum + c.profit, 0) / losingCycles.length || 0;
    const profitFactor = Math.abs(avgWin * winningCycles.length) / Math.abs(avgLoss * losingCycles.length) || 0;
    
    return {
      // 收益指标
      totalProfit,
      roi,
      annualizedReturn: this.annualizeReturn(roi),
      
      // 风险指标
      sharpeRatio,
      sortinoRatio,
      maxDrawdown,
      
      // 交易统计
      totalCycles: this.cycles.length,
      completedCycles: winningCycles.length + losingCycles.filter(c => c.status === 'COMPLETED').length,
      expiredCycles: losingCycles.filter(c => c.status === 'EXPIRED_LOSS').length,
      winRate,
      avgProfit,
      avgWin,
      avgLoss,
      profitFactor,
      
      // 时间统计
      tradingDays: this.calculateTradingDays(),
      avgCyclesPerDay: this.cycles.length / this.calculateTradingDays()
    };
  }

  calculateReturns() {
    const returns = [];
    for (let i = 1; i < this.equityCurve.length; i++) {
      const ret = (this.equityCurve[i].equity - this.equityCurve[i-1].equity) / this.equityCurve[i-1].equity;
      returns.push(ret);
    }
    return returns;
  }

  calculateSharpe(returns, riskFreeRate = 0) {
    if (returns.length === 0) return 0;
    
    const avgReturn = returns.reduce((a, b) => a + b, 0) / returns.length;
    const stdDev = Math.sqrt(returns.reduce((sum, r) => sum + Math.pow(r - avgReturn, 2), 0) / returns.length);
    
    if (stdDev === 0) return 0;
    
    // 年化 (假设每分钟一个数据点, 525600分钟/年)
    const annualizedReturn = avgReturn * 525600;
    const annualizedStd = stdDev * Math.sqrt(525600);
    
    return (annualizedReturn - riskFreeRate) / annualizedStd;
  }

  calculateSortino(returns, riskFreeRate = 0) {
    if (returns.length === 0) return 0;
    
    const avgReturn = returns.reduce((a, b) => a + b, 0) / returns.length;
    const negativeReturns = returns.filter(r => r < 0);
    
    if (negativeReturns.length === 0) return Infinity;
    
    const downsideDeviation = Math.sqrt(
      negativeReturns.reduce((sum, r) => sum + Math.pow(r, 2), 0) / negativeReturns.length
    );
    
    const annualizedReturn = avgReturn * 525600;
    const annualizedDownside = downsideDeviation * Math.sqrt(525600);
    
    return (annualizedReturn - riskFreeRate) / annualizedDownside;
  }

  calculateMaxDrawdown() {
    let peak = this.equityCurve[0]?.equity || 0;
    let maxDrawdown = 0;
    
    for (const point of this.equityCurve) {
      if (point.equity > peak) {
        peak = point.equity;
      }
      const drawdown = (peak - point.equity) / peak;
      if (drawdown > maxDrawdown) {
        maxDrawdown = drawdown;
      }
    }
    
    return maxDrawdown;
  }

  calculateTradingDays() {
    if (this.equityCurve.length === 0) return 0;
    const firstTime = this.equityCurve[0].timestamp;
    const lastTime = this.equityCurve[this.equityCurve.length - 1].timestamp;
    return (lastTime - firstTime) / (1000 * 60 * 60 * 24);
  }

  annualizeReturn(roi) {
    const days = this.calculateTradingDays();
    if (days === 0) return 0;
    return Math.pow(1 + roi, 365 / days) - 1;
  }
}
```

---

## 6. 回测报告

### 6.1 报告模板

```javascript
class ReportGenerator {
  static generateTextReport(metrics, config) {
    return `
╔══════════════════════════════════════════════════════════════════╗
║           POLYMARKET DUMP & HEDGE BACKTEST REPORT                ║
╠══════════════════════════════════════════════════════════════════╣
║ Configuration                                                     ║
╟──────────────────────────────────────────────────────────────────╢
║ Initial Balance:    $${config.initialBalance.toFixed(2).padStart(10)}                           ║
║ Shares per Trade:   ${config.shares.toString().padStart(10)}                                     ║
║ Sum Target:         ${config.sumTarget.toFixed(2).padStart(10)}                                  ║
║ Move Threshold:     ${(config.movePct * 100).toFixed(1).padStart(9)}%                            ║
║ Window (minutes):   ${config.windowMin.toString().padStart(10)}                                  ║
║ Fee Rate:           ${(config.feeRate * 100).toFixed(2).padStart(9)}%                            ║
║ Spread Buffer:      ${(config.spreadBuffer * 100).toFixed(2).padStart(9)}%                       ║
╠══════════════════════════════════════════════════════════════════╣
║ Performance Summary                                               ║
╟──────────────────────────────────────────────────────────────────╢
║ Total Profit:       $${metrics.totalProfit.toFixed(2).padStart(10)}                              ║
║ ROI:                ${(metrics.roi * 100).toFixed(2).padStart(9)}%                               ║
║ Annualized Return:  ${(metrics.annualizedReturn * 100).toFixed(2).padStart(9)}%                  ║
╠══════════════════════════════════════════════════════════════════╣
║ Risk Metrics                                                      ║
╟──────────────────────────────────────────────────────────────────╢
║ Sharpe Ratio:       ${metrics.sharpeRatio.toFixed(2).padStart(10)}                               ║
║ Sortino Ratio:      ${metrics.sortinoRatio.toFixed(2).padStart(10)}                              ║
║ Max Drawdown:       ${(metrics.maxDrawdown * 100).toFixed(2).padStart(9)}%                       ║
╠══════════════════════════════════════════════════════════════════╣
║ Trade Statistics                                                  ║
╟──────────────────────────────────────────────────────────────────╢
║ Total Cycles:       ${metrics.totalCycles.toString().padStart(10)}                               ║
║ Completed Cycles:   ${metrics.completedCycles.toString().padStart(10)}                           ║
║ Expired (Loss):     ${metrics.expiredCycles.toString().padStart(10)}                             ║
║ Win Rate:           ${(metrics.winRate * 100).toFixed(2).padStart(9)}%                           ║
║ Avg Profit/Cycle:   $${metrics.avgProfit.toFixed(4).padStart(10)}                                ║
║ Avg Win:            $${metrics.avgWin.toFixed(4).padStart(10)}                                   ║
║ Avg Loss:           $${metrics.avgLoss.toFixed(4).padStart(10)}                                  ║
║ Profit Factor:      ${metrics.profitFactor.toFixed(2).padStart(10)}                              ║
╠══════════════════════════════════════════════════════════════════╣
║ Time Statistics                                                   ║
╟──────────────────────────────────────────────────────────────────╢
║ Trading Days:       ${metrics.tradingDays.toFixed(1).padStart(10)}                               ║
║ Avg Cycles/Day:     ${metrics.avgCyclesPerDay.toFixed(2).padStart(10)}                           ║
╚══════════════════════════════════════════════════════════════════╝
`;
  }

  static generateCSV(trades) {
    const headers = ['timestamp', 'cycle_id', 'leg', 'side', 'shares', 'price', 'cost', 'profit'];
    const rows = trades.map(t => [
      new Date(t.timestamp).toISOString(),
      t.cycleId,
      t.leg,
      t.side,
      t.shares,
      t.price,
      t.cost,
      t.profit || ''
    ]);
    
    return [headers.join(','), ...rows.map(r => r.join(','))].join('\n');
  }
}
```

---

## 7. 回测限制说明

基于原始推文的分析，以下是回测框架的已知限制：

| 限制 | 影响 | 缓解措施 |
|------|------|----------|
| 数据量有限 | 可能无法覆盖所有市场情况 | 持续录制更多数据 |
| 1秒采样精度 | 无法捕捉毫秒级波动 | 提高采样频率 |
| 无订单簿深度 | 无法模拟市场冲击 | 保守估计滑点 |
| 假设即时成交 | 实际可能部分成交 | 增加成交延迟模拟 |
| 固定滑点 | 实际滑点可变 | 使用区间估计 |
| 无网络延迟 | 实际存在200-1500ms延迟 | 增加延迟模拟 |
| Leg2未成交=全损 | 可能过于保守 | 这是有意的保守假设 |
| 无市场冲击 | 大单会影响价格 | 限制单笔交易规模 |

---

## 8. 运行示例

```bash
# 录制数据 (持续运行)
node recorder.js --output ./data/btc_15m.db

# 运行回测
node backtest.js \
  --db ./data/btc_15m.db \
  --start "2025-01-01" \
  --end "2025-01-05" \
  --balance 1000 \
  --shares 20 \
  --sum-target 0.95 \
  --move-pct 0.15 \
  --window-min 2

# 参数优化
node optimize.js \
  --db ./data/btc_15m.db \
  --start "2025-01-01" \
  --end "2025-01-05" \
  --output ./results/optimization.json
```
